package alttp

import (
	"bytes"
	"o2/interfaces"
	"o2/snes"
	"o2/snes/asm"
	"o2/snes/emulator"
	"o2/util"
	"strings"
	"testing"
)

type testVT struct {
	// test name
	name string

	// individual bytes of SRAM to be set and tested
	sramInitial  []sramValue
	expectUpdate bool
	// individual bytes of SRAM to validate after sync but before local receive item
	sramBeforeReceive []sramValue

	// item to grant local player after sync
	itemReceived uint8

	// individual bytes of SRAM to validate after sync and local receive item
	sramAfterReceive []sramValue

	// expected front-end notification to be sent or "" if none expected
	wantNotification string
}

type sramValue struct {
	// offset from $7EF000 in WRAM, e.g. $340 for bow, $341 for boomerang, etc.
	offset uint16
	// value to set for the local player
	localValue uint8
	// value to set for the remote player syncing in
	remoteValue uint8
}

func runVTTest(t *testing.T, tests []testVT) {
	// load the ROM and WRAM snapshot:
	// this is a VT randomized ROM generated by https://alttpr.com/en/h/7Lyqon5LM2
	// and the WRAM snapshot is taken immediately after starting from Link's house
	romContents, wramContents := loadTestData(t)

	// parse the ROM:
	rom, err := snes.NewROM("vt-NoGlitches-open-ganon_7Lyqon5LM2.sfc", romContents)
	if err != nil {
		t.Fatal(err)
	}

	// patch the ROM:
	patcher := NewPatcher(rom)
	err = patcher.Patch()
	if err != nil {
		t.Fatal(err)
	}

	for i := range tests {
		tt := &tests[i]
		t.Run(tt.name, func(t *testing.T) {
			// create the CPU-only SNES emulator:
			system := emulator.System{
				Logger: &testingLogger{t},
				ShouldLogCPU: func(s *emulator.System) bool {
					if s.CPU.RK == 0x00 {
						return false
					}
					return true
				},
			}
			if err := system.CreateEmulator(); err != nil {
				t.Fatal(err)
			}

			// copy ROM into emulator:
			copy(system.ROM[:], rom.Contents)

			// copy WRAM snapshot into emulator:
			copy(system.WRAM[:], wramContents)

			// run the system to init SRAM:
			t.Log("emu reset")
			system.CPU.Reset()
			runUntil(t, &system, 0x00_8029, 0x1_000)
			t.Log("emu sram init")
			system.SetPC(0x00_802F)
			runUntil(t, &system, 0x1b_b205, 0x1_000_000)

			// instantiate the Game instance for testing:
			g := &Game{
				rom:              rom,
				IsCreated:        true,
				GameName:         "ALTTP",
				PlayerColor:      0x12ef,
				SyncItems:        true,
				SyncDungeonItems: true,
				SyncProgress:     true,
				SyncHearts:       true,
				SyncSmallKeys:    true,
				SyncUnderworld:   true,
				SyncOverworld:    true,
				SyncChests:       true,
				SyncTunicColor:   false,
			}
			g.Reset()

			// subscribe to front-end Notifications from the game:
			lastNotification := ""
			g.Notifications.Subscribe(interfaces.ObserverImpl(func(object interface{}) {
				lastNotification = object.(string)
				t.Logf("notify: '%s'", lastNotification)
			}))

			a := &asm.Emitter{
				Code: &bytes.Buffer{},
				Text: &strings.Builder{},
			}

			// set up SRAM per each player:
			g.players[1].Index = 1
			g.players[1].TTL = 255
			g.players[1].Name = "remote"
			for _, sram := range tt.sramInitial {
				system.WRAM[0xF000+sram.offset] = sram.localValue
				g.local.SRAM[sram.offset] = sram.localValue
				g.players[1].SRAM[sram.offset] = sram.remoteValue
			}

			// default to 8-bit:
			a.AssumeSEP(0x30)
			updated := g.generateUpdateAsm(a)
			if updated != tt.expectUpdate {
				t.Logf("%s", a.Text.String())
				t.Errorf("generateUpdateAsm() = %v, want %v", updated, tt.expectUpdate)
				return
			}
			if updated {
				a.Comment("restore 8-bit mode and return to RESET code:")
				a.SEP(0x30)
				a.RTS()
			}
			t.Logf("generated update code:\n%s", a.Text.String())

			// emit the asm into SRAM:
			aw := util.ArrayWriter{Buffer: system.SRAM[0x7C00:]}
			if _, err := a.Code.WriteTo(&aw); err != nil {
				t.Fatal(err)
			}

			// start at the `JSL preMainAddr` to jump into SRAM:
			system.SetPC(0x00_8056)
			// stop after the `RTL` from SRAM:
			runUntil(t, &system, 0x00_805a, 0x1_000_000)

			// copy SRAM shadow in WRAM into local player copy:
			copy(g.local.SRAM[:], system.WRAM[0xF000:])

			// verify SRAM values after sync:
			for _, sram := range tt.sramBeforeReceive {
				if actual, expected := system.WRAM[0xF000+sram.offset], sram.localValue; actual != expected {
					t.Errorf("local.SRAM[%#04x] = %02x, expected %02x", sram.offset, actual, expected)
				}
			}

			// run a game frame:
			//system.SetPC(0x00_8056)
			//runUntil(t, system, 0x00_805a, 0x1_000_000)
			//t.Log("HALT")

			// add local item:
			t.Logf("[$02D8] = $%02x; JSL AddReceivedItemExpanded", tt.itemReceived)
			system.SetPC(0x07_99F7) // AddReceivedItemExpanded
			system.WRAM[0x02D8] = tt.itemReceived
			runUntil(t, &system, 0x07_99FB, 0x1_000_000)

			//system.SetPC(0x09_85ED) // AddReceivedItemExpandedGetItem
			//runUntil(t, system, 0x09_85E4, 0x1_000_000)

			// copy SRAM shadow in WRAM into local player copy:
			copy(g.local.SRAM[:], system.WRAM[0xF000:])

			// verify SRAM values:
			for _, sram := range tt.sramAfterReceive {
				if actual, expected := system.WRAM[0xF000+sram.offset], sram.localValue; actual != expected {
					t.Errorf("local.SRAM[%#04x] = %02x, expected %02x", sram.offset, actual, expected)
				}
			}

			// call generateUpdateAsm() again for next frame to receive notifications:
			a.Code = &bytes.Buffer{}
			_ = g.generateUpdateAsm(a)

			if tt.wantNotification != "" && lastNotification != tt.wantNotification {
				t.Errorf("notification = '%s', expected '%s'", lastNotification, tt.wantNotification)
			}
		})
	}
}

func runUntil(t *testing.T, system *emulator.System, targetPC uint32, maxCycles uint64) {
	if !system.RunUntil(targetPC, maxCycles) {
		t.Errorf("CPU ran too long and did not reach PC=%#06x; actual=%#06x",
			targetPC,
			system.GetPC(),
		)
	}
}

func TestVT(t *testing.T) {
	runVTTest(t, []testVT{
		{
			name: "Progressive bow 1 with wood arrows",
			sramInitial: []sramValue{
				{
					offset:      0x38E,
					localValue:  0,
					remoteValue: 0,
				},
				{
					// have arrows:
					offset:     0x377,
					localValue: 1,
				},
				{
					// have no bow:
					offset:     0x340,
					localValue: 0,
				},
			},
			expectUpdate: false,
			// grant progressive bow:
			itemReceived: 0x64,
			sramAfterReceive: []sramValue{
				{
					// expect bow & arrows:
					offset:     0x38E,
					localValue: 0x80,
				},
				{
					// expect still have arrows:
					offset:     0x377,
					localValue: 1,
				},
				{
					// expect bow in inventory:
					offset:     0x340,
					localValue: 1,
				},
			},
		},
		{
			name: "Progressive bow 2 with silver arrows",
			sramInitial: []sramValue{
				{
					offset:      0x38E,
					localValue:  0x80,
					remoteValue: 0x80,
				},
				{
					// have arrows:
					offset:     0x377,
					localValue: 1,
				},
				{
					// have wood bow:
					offset:     0x340,
					localValue: 1,
				},
			},
			expectUpdate: false,
			// grant progressive bow:
			itemReceived: 0x64,
			sramAfterReceive: []sramValue{
				{
					// expect bow & silver arrows:
					offset:     0x38E,
					localValue: 0x80 | 0x40,
				},
				{
					// expect still have arrows:
					offset:     0x377,
					localValue: 1,
				},
				{
					// expect silver bow in inventory:
					offset:     0x340,
					localValue: 3,
				},
			},
		},
	})
}
